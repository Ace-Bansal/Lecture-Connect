'use strict';

var colors = require('colors/safe');

module.exports.create = function (deps) {
  var PromiseA = deps.PromiseA;
  var Oauth3 = deps.Oauth3;
  var CLI = deps.CLI || Oauth3.CLI;
  var A3 = deps.Oauth3.A3;
  var TLD;

  var path = require('path');
  var tldsCacheDir = deps.tldsCacheDir || path.join(require('os').homedir(), '.oauth3', 'caches', 'tlds');
  var requests = require('./requests.js').create(deps);

  function getPurchasedDomains(state) {
    return requests.domains.all(state.oauth3, state.session).then(function (regs) {
      state.purchasedDomains = regs.registrations;

      return regs.registrations;
    });
  }

  /*
  function getMyDomains(ws, state) {
    function loopit() {
      getMyDomain(ws, state);
    }

    if (!state.purchasedDomains) {
      getPurchasedDomains(ws, state, loopit);
    }
  }
  */

  var _domains = {};

  _domains.purchase = function (state) {
    return requests.domains.purchase(state.oauth3, state.session, {
      total: state.purchaseAmount
    , tip: state.tipAmount
    , domains: state.availableDomains.map(function (domain) {
        return {
          amount: Math.round(domain.usd.slice(1) * 100)
        , auth: domain.auth
        , sld: domain.sld
        , tld: domain.tld
        };
      })
    , currency: 'usd'
    , description: 'Purchase ' + state.availableDomains.length + ' domain(s).'
    , cardId: state.cards[0].id
    , customerId: state.cards[0].customer
    , email: state.ccEmail || state.username
    , addr: state.address
    }).then(function (results) {
      state.domainPurchases = results;
      return results;
    });
    /*
    A3.requests.purchase(state.oauth3, state.session, {
      amount: state.purchaseAmount
    , currency: 'usd'
    , description: 'Purchase example.com'
    , cardId: state.cards[0].id
    , customerId: state.cards[0].customer
    , email: state.ccEmail || state.username
    }).then(function (results) {
      console.log('[make purchase result]');
      console.log(results);
      process.exit(1);
      cb(null);
    });
     */
  };


  function searchDomains(providerUri, sld, tld) {
    providerUri = providerUri || 'api.oauth3.org';
    return A3.request({
      url: 'https://' + providerUri
        + '/api/com.daplie.domains/check-availability/'
        + sld + '/' + tld
    });
  }

  function initDomainsAsync(state, options) {
    if (!TLD) {
      TLD = require('./tlds.js').create(deps);
    }
    return TLD.getTldsAsync({ cacheDir: tldsCacheDir }).then(function () {
      // TODO max price
      state.maxPurchaseAmount = Math.round(parseFloat(options['max-purchase-price'], 10) * 100) || 0;

      if (options.tip) {
        state.tipDollars = parseFloat(options.tip, 10);
        if (!isNaN(state.tipDollars)) {
          state.tipAmount = Math.round(state.tipDollars * 100);
          state.tipped = true;
        }
      }

      state.dnSearch = {};
      state.dnSearchP = {};
      state.domains = [];
      state.availableDomains = [];
      state.rawDomains = (options.domains||'').split(',').map(function (domain) {
        return require('../lib/tld-hints').format({
          dnSearch: state.dnSearch
        , input: domain
        , tldsCacheDir: tldsCacheDir
          // TODO
        , _tlds: TLD.getTlds({ cacheDir: tldsCacheDir })
        });
      }).filter(function (domain) {
        return domain.searchable;
      });

      return PromiseA.all(state.rawDomains.map(function (domain) {
        if (!domain.searchable) {
          domain.valid = false;
          domain.na = true;
          domain.usd = 'ERR';
          return domain;
        }

        return getDomainAvailability({
          dnSearch: state.dnSearch
        , dnSearchP: state.dnSearchP
        , domainSearch: domain
        }).then(function (dn) {
          Object.keys(dn).forEach(function (k) {
            domain[k] = dn[k];
          });
          if (domain.available || domain.auth) {
            state.availableDomains.push(domain);
          }
          state.domains.push(domain);
        });
      })).then(function () {
        if (state.availableDomains.length && state.availableDomains.length === state.domains.length) {
          state.checkoutReady = true;
        }

        //Domains._cli.purchase();
      });
    });
  }

  function showCart(state) {
    var price;
    var transfers = [];
    var cartable = [];
    var noncartable = [];

    if (!state.domains.length) {
      return '';
    }

    state.domains.forEach(function (domain) {
      if (domain.auth && domain.na) {
        transfers.push(domain);
      }
      else if (!domain.na) {
        cartable.push(domain);
      }
      else {
        noncartable.push(domain);
      }
    });

    //state.msgs.push("-- CART --");
    if (cartable.length) {
      //state.msgs.push("");
      state.msgs.push("New Domain Registrations:");
      state.msgs.push("    " + cartable.map(function (domain) {
        return colors.cyan(domain.sld + '.' + domain.tld + ' ' + domain.usd);
      }).join(', '));
    }
    if (transfers.length) {
      //state.msgs.push("");
      state.msgs.push("Domain Transfers:");
      state.msgs.push("    " + transfers.map(function (domain) {
        return colors.cyan(domain.sld + '.' + domain.tld + ' ' + domain.usd);
      }).join(', '));
    }
    if (noncartable.length) {
      //state.msgs.push("");
      state.msgs.push("Not Avaliable:");
      state.msgs.push("    " + noncartable.map(function (domain) {
        return colors.red(domain.sld + '.' + domain.tld + ' N/A');
      }).join(', '));
    }
    state.msgs.push("");
    price = state.domains.reduce(function (price, domain) {
      if (domain.available || domain.auth) {
        return price + parseFloat(domain.usd.slice(1), 10);
      }
      return price;
    }, 0);
    state.msgs.push("Domain Subtotal: $" + price);

    state.domainSubtotal = Math.round(price * 100);
    return price;
  }

  function getDomainAvailability(state) {
    var r = state.domainSearch;
    var q = r.searchable;
    var tld  = r.tld;
    var sld = r.sld;

    // Reject queries against invalid domain name (empty secondary-level)
    if (!q || !sld) {
      return PromiseA.reject(new Error("don't submit non-domains please"));
    }

    if (state.dnSearchP[q]) {
      return state.dnSearchP[q];
    }

    state.dnSearchP[q] = searchDomains(state.providerUri, sld, tld).then(function (dns) {
      var dn = dns[0];

      // TODO round up to the nearest 50¢ or 10¢?
      // var rounder = 50;
      // dn.amount = Math.ceil(dn.amount/rounder) * rounder;
      dn.usd = '$' + Math.round(dn.amount / 100);
      // TODO cache results
      dn.tld = tld;
      dn.sld = sld;
      dn.updatedAt = Date.now();
      dn.na = !dn.available;
      state.dnSearch[q] = dn;

      return dn;
    }, function (err) {
      var dn = {};
      // TODO cache results
      dn.available = false;
      dn.tld = tld;
      dn.sld = sld;
      dn.updatedAt = Date.now();
      dn.usd = 'ERR';
      dn.na = true;
      dn.error = err;
      state.dnSearch[q] = dn;

      console.error("getDomainAvailability Error");
      console.error(err);
      console.error(err.stack);
      process.exit(1);

      return dn;
    });

    return state.dnSearchP[q];
  }

  function nextDomain(ws, state, cb) {
    state.state = 'nextdomain';
    state.hints = [ 'yes', 'no' ];
    state.msgs = [];
    showCart(state);
    state.msgs.push("");
    state.msgs.push("Continue Shopping?");
    state.prompt = "Add another domain to cart? [y/N]: ";

    CLI._handleInput(ws, state, function (err, result) {
      if (/^\s*y/i.test(result)) {
        searchDomain(ws, state, cb);
        return;
      }
      if (!result || /^\s*n/i.test(result)) {
        cb(null, null);
        return;
      }

      nextDomain(ws, state, cb);
      return;
    });
  }

  function searchDomain(ws, state, cb) {
    var tld = state.tld && ('.' + state.tld) || '';
    if (state.sld) {
      state.input = state.sld + tld;
    }
    state.state = 'domain';
    state.msgs = [
      "Search for an Available Domain"
        , ""
        , "First 6-months Free domains ($1/yr):"
        , "    .daplie.me"
        , ""
        , "Cheap domains (under $15/yr):"
        , "    .abc .biz .click .com .info .link" // me, us non-private
        , "    .name .one .org .rocks .work .xyz"
        , ""
        , "Other cool domains (under $25/yr):"
        , "    .band .blue .cloud .club .dance .earth .family"
        , "    .live .network .ninja .pink .pro .red .studio .today"
        , ""
    ];
    showCart(state);
    state.prompt = 'Search Domains: ';
    //state.prompt = 'American Express ';

    state.domains = state.domains || [];
    state.dnSearch = state.dnSearch || {};
    state.dnSearchP = state.dnSearchP || {};
    state.tldsCacheDir = tldsCacheDir; // TODO is this needed?
    state.inputCallback = function inputCallback(ws, state) {
      // TODO (there's a better way to pass getTldsAsync)
      state._tlds = TLD.getTlds({ cacheDir: tldsCacheDir });
      var r = state.domainSearch = require('../lib/tld-hints').format(state);
      var p;

      if (r.searchable && !state.dnSearch[r.searchable]) {
        p = getDomainAvailability(state).then(function () {
          if ('domain' === state.state
              && r.searchable === state.domainSearch.searchable
             ) {
            if (inputCallback === state.inputCallback) {
              state.inputCallback(ws, state);
            } else {
              // TODO (there's a better way to pass getTldsAsync)
              state._tlds = TLD.getTlds({ cacheDir: tldsCacheDir });
              require('../lib/tld-hints').format(state);
            }
          }
        });
      } else {
        p = PromiseA.resolve();
      }

      ws.cursorTo(0);
      CLI._writePrompt(ws, state);
      ws.write(r.complete);
      //ws.moveCursor(-1 * r.hintlen, 0);
      ws.cursorTo(state.prompt.length + state.input.length);

      return p;
    };

    CLI._handleInput(ws, state, function (err, result) {
      state.input = result;
      state.inputCallback(ws, state);
      state.input = '';
      state.inputCallback = null;

      if (err) {
        console.error("DEBUG: searchDomain Error");
        console.error(err.stack || err);
        cb(err);
        return;
      }

      function retry() {
        if (0 === state.domains.filter(function (domain) {
          return domain.available || domain.auth;
        }).length) {
          searchDomain(ws, state, cb);
          return;
        }

        nextDomain(ws, state, cb);
      }

      var r = require('../lib/tld-hints').format({
        dnSearch: state.dnSearch
      , input: result
      , tldsCacheDir: tldsCacheDir
        // TODO
      , _tlds: TLD.getTlds({ cacheDir: tldsCacheDir })
      });

      // TODO reject bad non-empty input from being ENTER-able
      if (!r.searchable) {
        retry();
        return;
      }
      if (!r.auth && r.na) {
        retry();
        return;
      }

      getDomainAvailability({
        dnSearch: state.dnSearch
      , dnSearchP: state.dnSearchP
      , domainSearch: r
      }).then(function (dn) {
        Object.keys(dn).forEach(function (k) {
          r[k] = dn[k];
        });
        if (r.available || r.auth) {
          state.availableDomains.push(r);
        }
        state.domains.push(r);
        retry();
      }, function (err) {
        console.error('[oauth3-cli] searchDomain Error');
        console.error(err.stack || err);
      });
    });

    // pre-fill suggestion
    state.inputCallback(ws, state);
  }

  function addDomainsToCart(ws, state, cb) {
    if (state.availableDomains.length) {
      if (state.checkoutReady) {
        cb(null, null);
        return;
      }

      nextDomain(ws, state, function (err) {
        state.checkoutReady = true;
        cb(err, null);
      });
      return;
    }

    searchDomain(ws, state, function (err) {
      state.checkoutReady = true;
      cb(err, null);
    });
  }

  function askTip(ws, state, cb) {
    state.state = 'asktip';
    state.hints = [];
    state.msgs = [];

    showCart(state);

    state.msgs.push("");
    state.msgs.push("We appreciate tips!");
    state.msgs.push("Give an extra buck for R&D of Awesomeness?");
    state.prompt = "Tip Amount (i.e. 0, 1, 5, 10): $";

    CLI._handleInput(ws, state, function (err, result) {
      /*
      // Github Issue #3
      // (I'm not sure what this code was supposed to do)
      if (price < 1 && parseFloat(result) < 1) {
        askTip(ws, state, cb);
        return;
      }
      */

      if (!/^\s*\d+(\.\d\d)?\s*$/i.test(result)) {
        askTip(ws, state, cb);
        return;
      }

      state.tipped = true;
      state.tipDollars = parseFloat(result || 0, 10);
      state.tipAmount = Math.round(state.tipDollars * 100);
      cb(null, null);
    });
  }

  function confirmPurchase(ws, state, cb) {
    state.state = 'confirmdomains';
    state.hints = [ 'buy', 'cancel' ];
    state.msgs = [];

    var price = showCart(state);

    if (state.maxPurchaseAmount >= (state.domainSubtotal + state.tipAmount)) {
      state.purchaseReady = true;
      state.purchaseAmount = state.domainSubtotal + state.tipAmount;
      state.hints = [];
      cb(null, null);
      return;
    }

    state.msgs.push("");
    state.msgs.push("Purchase domains (with Tip) for " + colors.cyan('$' + (price + state.tipDollars)));
    state.prompt = "Type 'buy' or 'cancel': ";

    CLI._handleInput(ws, state, function (err, result) {
      if (/^\s*buy\s*$/i.test(result)) {
        state.purchaseReady = true;
        state.purchaseAmount = state.domainSubtotal + state.tipAmount;
        cb(null, null);
        return;
      }
      else if (/^\s*cancel\s*$/i.test(result)) {
        console.info("Cancel purchase");
        process.exit(0);
        return;
      }
      else {
        confirmPurchase(ws, state, cb);
        return;
      }
    });
  }













  var Domains = Oauth3.Domains = { _cli: {} };
  Domains._getDomainPartsAsync = function (domainname) {
    if (!TLD) {
      TLD = require('./tlds.js').create(deps);
    }
    return TLD.getTldsAsync({ cacheDir: tldsCacheDir }).then(function (domains) {
      var opts;

      // XXX
      // TODO make own function
      // XXX
      domains.tlds.sort(function (a, b) {
        var numDotsA = (a.tld.match(/\./g)||'').length;
        var numDotsB = (b.tld.match(/\./g)||'').length;
        var diffDots = numDotsA - numDotsB;

        if (diffDots) {
          return diffDots;
        }

        return a.tld.length - b.tld.length;
      });

      //opts = { sub: options.sub, sld: options.sld, tld: options.tld, device: state.device.hostname };
      opts = { sub: '', sld: '', tld: '', };
      // TODO find a better better solution
      domains.tlds.push({ tld: 'dj' });
      domains.tlds.sort(function (a, b) {
        return b.tld.length - a.tld.length;
      }).some(function (tld) {
        var re = new RegExp('\\.' + tld.tld.replace(/\./g, '\\.') + '$');
        var parts;

        if (re.test(domainname)) {
          opts.tld = tld.tld;
          parts = domainname.replace('.' + tld.tld, '').split(/\./g);
          opts.sld = parts.pop();
          opts.sub = parts.join('.');
          return true;
        }
      });

      if (!opts.tld) {
        return PromiseA.reject(new Error("tld '" + domainname.split('.').pop() + "' does not match known tld list"));
      }

      return opts;
    });
  };
  Domains.all = function (options) {
    return Oauth3.login(options).then(function (state) {
      return getPurchasedDomains(state);
    });
  };
  Domains._cli.purchase = function (ws, state, cb) {
    function loopit() {
      Domains._cli.purchase(ws, state, cb);
    }

    if (!state.checkoutReady) {
      addDomainsToCart(ws, state, loopit);
    }
    else if (!state.tipped) {
      askTip(ws, state, loopit);
    }
    else if (!state.purchaseReady) {
      confirmPurchase(ws, state, loopit);
    }
    else if (!state.cards) {
      Oauth3.Cards._getCards(state, loopit);
    }
    else if (!state.address) {
      Oauth3.Addresses._getOrCreateMailingAddress(state).then(loopit);
    }
    else {
      _domains.purchase(state).then(function () {
        cb(null);
      }, cb);
    }
  };
  Domains.search = function (state, opts) {
    opts = opts || state;

    return Domains._getDomainPartsAsync(opts.domainname).then(function (parts) {
      return searchDomains(opts.providerUri, parts.sld, parts.tld);
    });
  };
  Domains.purchase = function (options) {
    options = options || {};
    return Oauth3.login(options).then(function (state) {
      Oauth3.Cards._init(state, options);
      Oauth3.Addresses._init(state, options);
      return initDomainsAsync(state, options).then(function () {
        var ws = CLI.init(process.stdin, process.stdout, state, options);
        return PromiseA.promisify(Domains._cli.purchase)(ws, state).then(function () {
          return state.domainPurchases;
        });
      });
    });
  };

  // opts = { domains, total, tip, email, cardId, customerId, address }
  // opts.domains = [{ name }]
  Domains.register = function (state, opts) {
    opts = opts || state;

    return PromiseA.all(opts.domains.map(function (domain) {
      return Domains._getDomainPartsAsync(domain.name).then(function (parts) {
        domain.usd = '$0';
        domain.sub = parts.sub;
        domain.sld = parts.sld;
        domain.tld = parts.tld;
      });
    })).then(function () {
      return requests.domains.purchase(state.oauth3, state.session, {
        currency: 'usd'
      , total: opts.total || 0
      , tip: opts.tip || 0
      , domains: opts.domains.map(function (domain) {
          return {
            amount: Math.round(domain.usd.slice(1) * 100)
          , auth: domain.auth
          , sld: domain.sld
          , tld: domain.tld
          };
        })
      , description: 'Register ' + opts.domains.length + ' domain(s).'
      , cardId: opts.cardId
      , customerId: opts.customerId
      , email: opts.email || state.email || state.credentialId || state.username
      , addr: opts.address
      });
    });
  };

  Domains.release = function (options) {
    var domainnames = options.domains || options.names || options.domainnames;
    options = options || {};

    return Oauth3.login(options).then(function (state) {
      return PromiseA.all(domainnames.split(',').map(function (domainname) {

        return Domains._getDomainPartsAsync(domainname).then(function (domainparts) {

          options.sub = domainparts.sub;
          options.sld = domainparts.sld;
          options.tld = domainparts.tld;

          return requests.domains.release(state.oauth3, state.session, options);
        });
      }));
    });
  };

  var Glue = Oauth3.Glue = {};
  Glue.all = function (options) {
    return Oauth3.login(options).then(function (state) {
      return requests.glue.all(state.oauth3, state.session);
    });
  };
  Glue.set = function (options) {
    var p;

    if (options.defaults) {
      p = Domains._getDomainPartsAsync(options.name).then(function (o) {
        return [
          { tld: o.tld
          , sld: o.sld
          , sub: 'ns1'
          , ip: '192.241.238.7'
          }
        , { tld: o.tld
          , sld: o.sld
          , sub: 'ns2'
          , ip: '66.172.33.29'
          }
        ];
      });
    }
    else {
      p = Domains._getDomainPartsAsync(options.name).then(function (o) {
        o.ip = options.address;
        return PromiseA.resolve([ o ]);
      });
    }

    return Oauth3.login(options).then(function (state) {
      return p.then(function (records) {
        return PromiseA.all(records.map(function (r) {
          return requests.glue.set(state.oauth3, state.session, r);
        }));
      });
    });
  };

  var Ns = Oauth3.Ns = {};
  Ns.get = function (options) {
    var dns = PromiseA.promisifyAll(require('dns'));

    return dns.resolveNsAsync(options.name);
  };
  Ns.set = function (options) {
    if (options.defaults) {
      options.nameservers = [ 'ns1.redirect-www.org', 'ns2.redirect-www.org' ];
    }
    if ('string' === typeof options.nameservers) {
      options.nameservers = options.nameservers.split(',');
    }
    options.domainname = options.domainame || options.name;

    return Domains._getDomainPartsAsync(options.name).then(function (o) {
      return Oauth3.login(options).then(function (state) {
        options.tld = o.tld;
        options.sld = o.sld;
        return requests.ns.set(state.oauth3, state.session, options);
      });
    }).then(function () {
      return { name: options.name, nameservers: options.nameservers };
    });
  };

  return Oauth3;
};
