'use strict';

// { A3, Oauth3, PromiseA }
module.exports.create = function (deps) {
  var Domains = deps.Domains;
  //var Domains = require('daplie-domains').create(deps);
  var Oauth3 = deps.Oauth3;
  //var PromiseA = deps.PromiseA;
  // { A3, PromiseA }
  var requests = require('./requests').create(deps);



  var Dns = Oauth3.Dns = {};

  Dns._dnsValueType = function (value) {
    var type;

    if (/^\d+\.\d+\.\d+\.\d+$/.test(value)) {
      type = 'A';
    }
    else if (-1 !== value.indexOf(':') && /^[a-f:\.\d]+$/i.test(value)) {
      type = 'AAAA';
    }
    else if (/^https?:\/\/.*$/i.test(value)) {
      type = 'FWD';
    }
    else if (/[\w\-]+\.[\w\-]+/i.test(value)) {
      type = 'ANAME';
    }

    return type;
  };

  Dns.all = function (state, opts) {
    // backwards compat
    opts = opts || state;

    return Oauth3.login(state).then(function (state) {
      return requests.dns.all(state.oauth3, state.session);
    });
  };

  Dns.get = function (state, opts) {
    // backwards compat
    opts = opts || state;

    return Oauth3.login(state).then(function (state) {
      var domainname = opts.domain || opts.name || opts.domainname;

      return Domains._getDomainPartsAsync(domainname).then(function (parts) {
        return requests.dns.get(state.oauth3, state.session, parts);
      });
    });
  };

  Dns.set = function (state, opts) {
    // backwards compat
    opts = opts || state;

    var domainname = opts.domainname || opts.domain || opts.name;

    return Domains._getDomainPartsAsync(domainname).then(function (domainparts) {

      opts.sub = domainparts.sub;
      opts.sld = domainparts.sld;
      opts.tld = domainparts.tld;

      return Oauth3.login(state).then(function (state) {
        var opts2 = {
          name: domainname //(opts.sub ? opts.sub + '.' : '') + opts.sld + '.' + opts.tld
        , type: opts.type || 'A'
        , value: opts.answer || opts.value
        , ttl: opts.ttl || 600
        , priority: opts.priority || 10
        , sub: domainparts.sub
        , sld: domainparts.sld
        , tld: domainparts.tld
        };

        return requests.dns.set(state.oauth3, state.session, opts2);
      });
    });
  };

  Dns.destroy = function (state, opts) {
    // backwards compat
    opts = opts || state;

    var domainname = opts.domain || opts.name || opts.domainname;

    return Domains._getDomainPartsAsync(domainname).then(function (domainparts) {

      opts.sub = domainparts.sub || '.';
      opts.sld = domainparts.sld;
      opts.tld = domainparts.tld;

      return Oauth3.login(state).then(function (state) {
        var opts2 = {
          name: domainname //(opts.sub ? opts.sub + '.' : '') + opts.sld + '.' + opts.tld
        , type: opts.type || 'A'
        , value: opts.answer || opts.value
        , sub: opts.sub || '.'
        , sld: opts.sld
        , tld: opts.tld
        };

        return requests.dns.destroy(state.oauth3, state.session, opts2);
      });
    });
  };




  //
  // Devices
  //
  var Devices = Oauth3.Devices = {};
  Devices.token = function (state, opts) {
    // backwards compat
    opts = opts || state;

    return Oauth3.login(state).then(function (state) {
      // TODO cache token on disk
      return requests.devices.token(state.oauth3, state.session, opts);
    });
  };

  Devices.attach = function (state, opts) {
    // backwards compat
    opts = opts || state;
    opts.device = opts.devicename || opts.device || opts.name;
    opts.domain = opts.domainname || opts.domain || opts.name;
    // device, domain, update, ttl, priority, addresses

    return Domains._getDomainPartsAsync(opts.domain).then(function (domainparts) {
      opts.sub = domainparts.sub;
      opts.sld = domainparts.sld;
      opts.tld = domainparts.tld;

      return Oauth3.login(state).then(function (state) {
        return requests.devices.attach(state.oauth3, state.session, opts);
      });
    });
  };

  Devices.detach = function (state, opts) {
    // backwards compat
    opts = opts || state;
    // opts = { addresses, devicename }
    opts.devicename = opts.devicename || opts.device || opts.name;
    opts.domain = opts.domainname || opts.domain || opts.name;

    return Domains._getDomainPartsAsync(opts.domain).then(function (domainparts) {
      opts.sub = domainparts.sub;
      opts.sld = domainparts.sld;
      opts.tld = domainparts.tld;

      return Oauth3.login(state).then(function (state) {
        return requests.devices.detach(state.oauth3, state.session, opts);
      });
    });
  };

  Devices.all = function (state, opts) {
    // backwards compat
    opts = opts || state;

    return Oauth3.login(state).then(function (state) {
      return requests.devices.all(state.oauth3, state.session);
    });
  };

  Devices.set = function (state, opts) {
    // backwards compat
    opts = opts || state;
    // opts = { addresses, devicename }
    opts.devicename = opts.devicename || opts.device || opts.name;

    return Oauth3.login(state).then(function (state) {
      var errs = [];

      if (!Array.isArray(opts.addresses)) {
        opts.addresses = (opts.addresses||'').split(',').filter(Boolean).map(function (address) {
          var result = {
            value: address
          , type: Dns._dnsValueType(address)
          };

          return result;
        });
      }

      opts.addresses.forEach(function (address) {
        if (-1 === [ 'A', 'AAAA' ].indexOf(address.type)) {
          errs.push("'" + address.value + "' is not a valid IPv4 or IPv6 address");
          return true;
        }
      });

      if (errs.length) {
        console.log("");
        errs.forEach(function (msg) {
          console.error(msg);
        });
        console.log("");
        process.exit(1);
      }

      if (!opts.addresses.length) {
        opts.addresses = undefined;
      }

      return requests.devices.set(state.oauth3, state.session, opts);
    });
  };

  Devices.destroy = function (state, opts) {
    // backwards compat
    opts = opts || state;

    // options = { addresses, devicename }
    opts.devicename = opts.devicename || opts.device || opts.name;
    if ('delete' !== opts.confirm) {
      console.error("You must must specify --confirm delete to remove a device from all domains");
      process.exit(1);
      return;
    }

    return Oauth3.login(state).then(function (state) {
      return requests.devices.destroy(state.oauth3, state.session, opts);
    });
  };




  return Oauth3;
};
